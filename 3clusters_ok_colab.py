# -*- coding: utf-8 -*-
"""3clusters_ok_colab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GJhCxZTstOvjc2pqRGNdMhtVSPDEJs7E
"""

# programa 3clusters_original_Copy100 - artigo cluster melhor rota menor potencia V14.0
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# ok - colab
#----------------------------------------------------------------------------------------
"""
3clusters_original_1000 figura PNG-------------> 09/03/2024
Trabalho final de Machine Learning
Projeto de Pesquisa Engenharia Elétrica Unesp SJBV
CLUSTERS
 3 clusters in 2 dimensions
- Implement the k-means algorithm and train the system:
   - Initialize the cluster centers in random points (colored circles)
   - Adopt as your distance criteria the R from Friis´ Law
GOAL: Plot the path of the 3 centers (like in the first figure!)
""
@author: mauricio
"""
import random,  math
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle, PathPatch
from matplotlib.text import TextPath
from matplotlib.transforms import Affine2D
# This import registers the 3D projection, but is otherwise unused.
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
import mpl_toolkits.mplot3d.art3d as art3d

def Minkowski(point, center, lamb):
  v = []
  for k in range(0, len(point)):
      dif = (abs((point[k] - center[k])))**lamb
      v.append(dif)
  dist = sum(v)**(1/lamb)
  return(dist)
# generation of points (x,y) that means power of 2 antennas
def generatepoints(totSensors,  limit):
    global XY
    XY = []
    for x in range(totSensors):
        valueX = random.randint(1,limit)
        valueY = random.randint(1,limit)
        xy = (valueX, valueY)
        XY.append(xy)
    print(XY)
    return(XY)

# Variables Initialization
# TRANSCEIVER Frequency 2,4 Ghz (obtained from datasheet)
FREQ=2.4*10**9
# Reception Power (dBm)
PrdBm=-80
# Transmition Power (dBm)
Pt_transceiver=0.001 #centroid
Pr=10**(PrdBm/10)/1000
# Sensors Position (x,y) Distance Calculation
# Euclidian Distance between sensors (Pitagoras)
deltax = 0.
deltay = 0.
def calculaR(x1, x2, y1, y2):
    global R
    R = 0.
    deltax = x1-x2
    deltay = y1-y2
    R =  (deltax**2 + deltay**2)**0.5
    return(R)
#Max Ray calculation from Friis´s Law
def RMax(Pt,  Pr,  LAMBDA):
    rmax = ((Pt/Pr)**0.5)*LAMBDA/(4*math.pi)
    return(rmax)
totSensors = 0
# official speed of ligtht
LAMBDA = 299792458/(FREQ)
r=RMax(Pt_transceiver,Pr,LAMBDA)

print(r)
# number of iterations of loop of the clusters

var_iteration=1000

# B PART --------------------------
#totSensors = int(input('Defina o total de pontos: '))
#limit = int(input('Defina a faixa randomica: '))
# ------------------------------------------------------ Sensores e Range --------------
# GERAR 128 PONTOS X,Y RANDOMICAMENTE  that represents position of SENSORS
totSensors =128
limit = 400 #top range of points
generatepoints(totSensors, limit)
#Initialization
# CALCULAR AS POTÊNCIAS DE TRANSMISSÃO DAS ANTENAS
# LEI DE FRIIS --- POTÊNCIA TRANSMITIDA DE UMA ANTENA PARA OUTRA
#FIXAR AS CONSTANTES GT E GR
GT = 1.
GR = 1.
R = 1.
# initialization POTÊNCIA DE TRANSMISSÃO DA ANTENA
PT = 1.
# initialization POTÊNCIA DE RECEPÇÃO DA ANTENA
PR = 1.
# USAREMOS UM TRANSCEIVER ARDUINO DE FREQUÊNCIA 2.4 GHz (Datasheet)
# USANDO V = LAMBDA * F, onde V = velocidade da Luz 299.792.458 Km/s
# https://pt.wikipedia.org/wiki/Velocidade_da_luz
# 299.792.458 = LAMBDA * 2.4*10**9
# temos que LAMBDA = 299.792.458/2.4
#print('LAMBDA = ',  LAMBDA)

PT = PR/(GT*GR*((LAMBDA/4*math.pi*R)**2))

# - CALCULAR O R (EUCLIDEANA/PITÁGORAS),
#print('R = ',  R)
## CALCULAR A DISTANCIA
## CALCULAR A POTENCIA TRANSMITIDA E RECEBIDA
## USAR A MENOR POTENCIA PARA TRANSMITIR
pontosx = []
pontosy = []
#print('lenXY = ', len(XY))
#print('XY fora do def',  XY)
for i in range(0,len(XY)):
     x = float(XY[i][0])
     y = float(XY[i][1])
     pontosx.append(x)
     pontosy.append(y)
# ------Data generated must be saved to be runnable -----
# creating an new empty file to save all points/sensors
salvos = 0
file = open('C:\pointsxy.txt', 'w')
file.close()
file = open('C:\pointsxy.txt', 'w') # Abre novamente o arquivo (write)

pontosR = []
# --------------quarta --A FAZER ------
# 1) calculo dist x,y ===> centroide
# 2) automatizar +clusters (cor automática, RGB)
# 3) validar (x,y) está dentro do raio r do centroide do cluster considerado
#------------------ quinta - 05/12-------------------
# CALCULAR o R entre o centroide e cada ponto (x,y)
#a) MATRIZ DISTÂNCIA: REFAZER esse laço: de M X N (128X128)
#PointsRmax = []
# distance calculation between points ---------------R --------
# duvida: este laço entre pontos é inutil ???? pend
for i in range(len(pontosx)):
    # fixar o primeiro ponto e comparar com n-1 outros
     x = pontosx[i]
     y = pontosy[i]
     for j in range(0,  (len(pontosx)-1)):
#         GreaterMaxRadius = 0.
         x2 = pontosx[j]
         y2 = pontosy[j]
         if (x-x2 ==0) and (y-y2==0):
             R = 0
         elif i < (len(pontosx)-1):
             #print('i = ',  i)
             x2 = pontosx[i+1]
             y2 = pontosy[i+1]
            # alteracao
            # calcular R de centroide a nós  - quinta
            #------------------------------este calcula inter-pontos.....!!!
             calculaR(x, x2, y, y2)
             #print('x,x2,y,y2,R = ', x, x2, y, y2, R)
             ## CALCULAR A POTENCIA TRANSMITIDA ------------------------PT
             PT = PR/(GT*GR*((LAMBDA/4*math.pi*R)**2))
             # --- CALCULAR O RMAX--------------------------
             pontosR.append(str(pontosx[i])+" "+str(pontosy[i])+" "+str(pontosx[i+1])+" "+str(pontosy[i+1])+" "+str(R)+" "+str(PT)+str('\n'))
             file.write(str(pontosx[i])+" "+str(pontosy[i])+" "+str(pontosx[i+1])+" "+str(pontosy[i+1])+" "+str(R)+" "+str(PT)+str('\n'))
             salvos = salvos+1
         else:
             pontosR.append(str(pontosx[i-1])+" "+str(pontosy[i-1])+" "+str(pontosx[i])+" "+str(pontosy[i])+" "+str(R)+" "+str(PT))
             file.write(str(pontosx[i-1])+" "+str(pontosy[i-1])+" "+str(pontosx[i])+" "+str(pontosy[i])+" "+str(R)+" "+str(PT))
             salvos = salvos+1
file.close()
print('records = ', salvos)

# centroids initialization
# parâmetro: numero de centroides do K-means => K <=
# --------------- alteracao => usar os pontos x,y do generatepoints
# k if fixed, at this moment.
k = 3
x1 = random.uniform(0,limit)
y1 = random.uniform(0,limit)
x2 = random.uniform(0,limit)
y2 = random.uniform(0,limit)
x3 = random.uniform(0,limit)
y3 = random.uniform(0,limit)
#Assign the cluster centers ! " to those points
m1=(x1,y1)
m2=(x2,y2)
m3=(x3,y3)
# saving randomic centroids
file2 = open('C:\centroids_start.txt', 'w')
file2.close()
file2 = open('C:\centroids_start.txt', 'w') # Abre novamente o arquivo (write)
file2.write(str(m1)+" "+str(m2)+" "+str(m3)+str('\n'))
file2.close()

#print('m1,m2,m3 ', m1, m2, m3)
### para ver se o centro caminhou...
centrosx1 = []
centrosx2 = []
centrosx3 = []
centrosy1 = []
centrosy2 = []
centrosy3 = []
centrosx1.append(x1)
centrosx2.append(x2)
centrosx3.append(x3)
centrosy1.append(y1)
centrosy2.append(y2)
centrosy3.append(y3)
#Learning
#§ Repeat until the cluster centers stop moving:
#while ..........
#    For each datapoint # $ :
#▪ Compute the distance from Xi to each cluster center m1,m2,m3
#Assign the datapoint to the nearest cluster center mj with distance % $ = min % # $ , ! ")
d1 = []
d2 = []
d3 = []
cluster = 0
centerc1 = []
centerc2 = []
centerc3 = []
centerc1x = []
centerc2x = []
centerc3x = []
centerc1y = []
centerc2y = []
centerc3y = []
############### LEARNING #######################
######### distance
iteration = 0
centers1x = []
centers1y = []
centers2x = []
centers2y = []
centers3x = []
centers3y = []
d1x = []
d1y = []
d2x = []
d2y = []
d3x = []
d3y = []
plt.clf
#alterar para erro = 0
# rever aqui: condicao de parada == ERRO = 0
#pend
# --------------------------------alterar aqui ----------------- while ---------------]
# PARAR QUANDO OS CENTROIDES NAO ANDAREM MAIS...
while iteration < var_iteration:
    iteration = iteration + 1
    #print('iteration ', iteration)
    #print('gerando OS 3 CLUSTERs',len(pontosx))
    for i in range(0,len(pontosx)):
        pointcluster = ''
        dist1 = 0.
        dist2 = 0.
        dist3 = 0.
        x = pontosx[i]
        y = pontosy[i]
# nao alteracao do calculo distancia  do ponto para o ponto médio atual
        dist1 =  (Minkowski((x,y), m1, 1))
        dist2 = (Minkowski((x,y), m2, 1))
        dist3 = (Minkowski((x,y), m3, 1))
        #d = dist1, dist2, dist3
        #print(d)
        # put x,y in his nearest Cluster: classification
        if (dist1 < dist2) and (dist1 < dist3):
            cluster = 1
            pointcluster=str(x)+' '+str(y)+' '+str(dist1)+' '+str(cluster)
            d1.append(pointcluster)
            d1x.append(x)
            d1y.append(y)
        if (dist2 < dist3) and (dist2 < dist1):
            cluster = 2
            pointcluster=str(x)+' '+str(y)+' '+str(dist2)+' '+str(cluster)
            d2.append(pointcluster)
            d2x.append(x)
            d2y.append(y)
        if (dist3 < dist1) and (dist3 < dist2):
            cluster = 3
            pointcluster=str(x)+' '+str(y)+' '+str(dist2)+' '+str(cluster)
            d3.append(pointcluster)
            d3x.append(x)
            d3y.append(y)
    sumx1 = 0
    sumx2 = 0
    sumx3 = 0
    sumy1 = 0
    sumy2 = 0
    sumy3 = 0
    for j in range(0,len(d1x)):
        x = d1x[j]
        y = d1y[j]
        sumx1 = sumx1 + x
        sumy1 = sumy1 + y
    for k in range(0,len(d2x)):
        x = d2x[k]
        y = d2y[k]
        sumx2 = sumx2 + x
        sumy2 = sumy2 + y
    for m in range(0, len(d3x)):
        x = d3x[m]
        y = d3y[m]
        sumx3 = sumx3 + x
        sumy3 = sumy3 + y
    n1 = len(d1x)
    n2 = len(d2x)
    n3 = len(d3x)
    meanc1x1 = 0.
    meanc2x2 = 0.
    meanc3x3 = 0.
    meanc1y1 = 0.
    meanc2y2 = 0.
    meanc3y3 = 0.
    meanc1x1 = sumx1/n1
    meanc2x2 = sumx2/n2
    meanc3x3 = sumx3/n3
    meanc1y1 = sumy1/n1
    meanc2y2 = sumy2/n2
    meanc3y3 = sumy3/n3
    meanc1 = 0.
    meanc2 = 0.
    meanc3 = 0.
#    print('meanc1x1,y1...',meanc1x1,meanc1y1)
#    print('meanc2x2 y2', meanc2x2,meanc2y2)
#    print('meanc2x3 y3', meanc3x3,meanc3y3)
#For each cluster center:
#▪ Pre-Move the position of the center to the mean of the points in the data cluster
    meanc1 = (meanc1x1,meanc1y1)
    centers1x.append(meanc1x1)
    centers1y.append(meanc1y1)
    meanc2 = (meanc2x2,meanc2y2)
    centers2x.append(meanc2x2)
    centers2y.append(meanc2y2)
    meanc3 = (meanc3x3,meanc3y3)
    centers3x.append(meanc3x3)
    centers3y.append(meanc3y3)
    x1 = meanc1x1
    y1 = meanc1y1
    x2 = meanc2x2
    y2 = meanc2y2
    x3 = meanc3x3
    y3 = meanc3y3
############ move the center to the mean of the points in the data cluster
    m1 = meanc1
    m2 = meanc2
    m3 = meanc3
    totin1 = 0
    totin2 = 0
    totin3 = 0
    totout1 = 0
    totout2 = 0
    totout3 = 0

# Check if (x,y) of a New centroid(i) is in range of his RMax Ray.
# if no, create another cluster and repeat the process...
# centroid #1
    for j in range(0,len(d1x)):
        x = d1x[j]
        y = d1y[j]
        calculaR(x,x1,y,y1)
        if R > r:
            # itsn´t in RMax
            # create another cluster
            totout1 = totout1 + 1
            #print('point ', x,y, 'is outside of RMax1')
        else:
            totin1 = totin1 + 1
            #print('point ', x,y, 'is inside of RMax1')
# centroid #2
    for j in range(0,len(d2x)):
        x = d2x[j]
        y = d2y[j]
        calculaR(x,x1,y,y1)
        if R > r:
            # itsn´t in Rmax
            # create another cluster
            totout2 = totout2 + 1
            #print('point ', x,y, 'is outside of RMax2')
        else:
            totin2 = totin2 + 1
            #print('point ', x,y, 'is inside of RMax2')
# centroid #3
    for j in range(0,len(d3x)):
        x = d3x[j]
        y = d3y[j]
        calculaR(x,x1,y,y1)
        if R > r:
            # itsn´t in Rmax
            # create another cluster
            totout3 = totout3 + 1
            #print('point ', x,y, 'is outside of RMax3')
        else:
            totin3 = totin3 + 1
            #print('point ', x,y, 'is inside of RMax3')

#------------------- create anoter cluster-------- fazer sexta..

# end of loop -------------------------------------------- end of loop ----------
print('totin1 = ', totin1, ' totout1 = ', totout1)
print('totin2 = ', totin2, ' totout2 = ', totout2)
print('totin3 = ', totin3, ' totout3 = ', totout3)

# Calcular o RMax com os centroides (02dez2019)
# duvida: para o centroixe x1,y1 , para calcular o R, pego o x,y mais distante? pend abaixo?
calculaR(x1, x2, y1, y2)
#print('x,x2,y,y2,R = ', x, x2, y, y2, R)
# CALCULAR A POTENCIA TRANSMITIDA
PT = PR/(GT*GR*((LAMBDA/4*math.pi*R)**2))
# calculate MaxRadius for each centroid.............. pend
MaxRadius = RMax(PT, PR, LAMBDA)
print(PT, MaxRadius)
# C PART
#  Plot the path of the 3 centers (like in the first figure!)

# TESTE1 FIG 1
plt.figure(figsize=(8, 6))  # Largura: 6.4 polegadas, Altura: 4.8 polegadas
#plt.figure(figsize=(15, 10))  # Largura: 6.4 polegadas, Altura: 4.8 polegadas

plt.figure(1)
plt.clf()
plt.plot(centers1x, centers1y,'--ro'  )
plt.plot(centers1x[iteration-1],centers1y[iteration-1],'ko',markersize =10)
plt.plot(centers2x, centers2y,'--ro')
plt.plot(centers2x[iteration-1],centers2y[iteration-1],'ko',markersize =10)
plt.plot(centers3x, centers3y,'--ro')
plt.plot(centers3x[iteration-1],centers3y[iteration-1],'ko',markersize =10)
plt.plot(d1x,d1y,'r+')
plt.plot(d2x,d2y,'g+')
plt.plot(d3x,d3y,'m+')

Graph_min=10
Graph_max=400
Graph_div=50
# D PART
# Plot the circle with ray r, from Potency Pt
#plt.figure(figsize=(10,10))
#ax = plt.gca(aspect='equal')
#plt.figure(figsize=(10,10))

# TESTE2  9 MAR 2024
# Criar uma figura com o tamanho desejado
plt.figure(figsize=(10, 8))  # Largura: 6.4 polegadas, Altura: 4.8 polegadas
#plt.figure(figsize=(15, 10))  # Largura: 6.4 polegadas, Altura: 4.8 polegadas


ax = plt.gca()
ax.set_aspect('equal')  # Define o aspect ratio
Graph_min=10
Graph_max=400

Graph_div=50

plt.xlim((Graph_min, Graph_max))
plt.ylim((Graph_min, Graph_max))

plt.plot(centers1x, centers1y,'--ro'  )
plt.plot(centers1x[iteration-1],centers1y[iteration-1],'ko',markersize =10)
plt.plot(centers2x, centers2y,'--ro')
plt.plot(centers2x[iteration-1],centers2y[iteration-1],'ko',markersize =10)
plt.plot(centers3x, centers3y,'--ro')
plt.plot(centers3x[iteration-1],centers3y[iteration-1],'ko',markersize =10)
plt.plot(d1x,d1y,'r+')
plt.plot(d2x,d2y,'g+')
plt.plot(d3x,d3y,'m+')



circle=plt.Circle((x1,y1),r,fill=True,alpha=0.3)
ax.add_artist(circle)
circle=plt.Circle((x2,y2),r,fill=True,alpha=0.3)
ax.add_artist(circle)
circle=plt.Circle((x3,y3),r,fill=True,alpha=0.3)
ax.add_artist(circle)

#plt.plot(plotSX,plotSY,'rD', markersize=5)
# pend certo aqui ?
#plt.xticks(np.arange(Graph_min, Graph_max,Graph_div))
#plt.yticks(np.arange(Graph_min, Graph_max,Graph_div))

print(r)
plt.title("Energy Efficiency applying K-means Clustering")
plt.xlabel("X Axis")
plt.ylabel("Y Axis")
plt.show()
plt.savefig('K-means')

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Trabalho final de Machine Learning
Projeto de Pesquisa Engenharia Elétrica Unesp SJBV
CLUSTERS
 3 clusters in 2 dimensions
- Implement the k-means algorithm and train the system:
   - Initialize the cluster centers in random points (colored circles)
   - Adopt as your distance criteria the R from Friis´ Law
GOAL: Plot the path of the 3 centers (like in the first figure!)
"""
import random
import math
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import

def minkowski(point, center, lamb):
    return sum(abs(p - c)**lamb for p, c in zip(point, center))**(1/lamb)

def generate_points(tot_sensors, limit):
    points = [(random.randint(1, limit), random.randint(1, limit)) for _ in range(tot_sensors)]
    print(points)
    return points

def calcula_r(x1, x2, y1, y2):
    return ((x1 - x2)**2 + (y1 - y2)**2)**0.5

def r_max(pt, pr, lamb):
    return ((pt / pr)**0.5) * lamb / (4 * math.pi)

# Initialization
FREQ = 2.4 * 10**9
PR_DBM = -80
PT_TRANSCEIVER = 0.001
PR = 10**(PR_DBM / 10) / 1000
LAMBDA = 299792458 / FREQ
r = r_max(PT_TRANSCEIVER, PR, LAMBDA)

tot_sensors = 128
limit = 400
points = generate_points(tot_sensors, limit)

GT = GR = 1.
R = 1.
PT = PR / (GT * GR * ((LAMBDA / (4 * math.pi * R))**2))

pontosx, pontosy = zip(*points)

with open('C:\\pointsxy.txt', 'w') as file:
    pontos_r = []
    for i in range(len(pontosx)):
        for j in range(i + 1, len(pontosx)):
            x1, y1 = pontosx[i], pontosy[i]
            x2, y2 = pontosx[j], pontosy[j]
            R = calcula_r(x1, x2, y1, y2)
            PT = PR / (GT * GR * ((LAMBDA / (4 * math.pi * R))**2))
            pontos_r.append(f"{x1} {y1} {x2} {y2} {R} {PT}\n")
            file.write(f"{x1} {y1} {x2} {y2} {R} {PT}\n")
    print('records = ', len(pontos_r))

k = 3
centroids = [(random.uniform(0, limit), random.uniform(0, limit)) for _ in range(k)]

with open('C:\\centroids_start.txt', 'w') as file:
    file.write(' '.join(map(str, centroids)) + '\n')

centrosx, centrosy = zip(*centroids)
centrosx1, centrosy1 = [centrosx[0]], [centrosy[0]]
centrosx2, centrosy2 = [centrosx[1]], [centrosy[1]]
centrosx3, centrosy3 = [centrosx[2]], [centrosy[2]]

var_iteration = 100
iteration = 0

while iteration < var_iteration:
    iteration += 1
    clusters = [[] for _ in range(k)]
    for x, y in points:
        distances = [minkowski((x, y), centroids[j], 1) for j in range(k)]
        cluster_index = np.argmin(distances)
        clusters[cluster_index].append((x, y))

    new_centroids = []
    for cluster in clusters:
        new_centroids.append((np.mean([x for x, y in cluster]), np.mean([y for x, y in cluster])))

    if new_centroids == centroids:
        break

    centroids = new_centroids
    centrosx1.append(centroids[0][0])
    centrosy1.append(centroids[0][1])
    centrosx2.append(centroids[1][0])
    centrosy2.append(centroids[1][1])
    centrosx3.append(centroids[2][0])
    centrosy3.append(centroids[2][1])

#CORRIGIDO AQUI 27JUNH24
fig, ax = plt.subplots(figsize=(10, 10))
ax.set_aspect('equal')

# ... rest of your code ...

plt.figure(figsize=(10,10))
ax = plt.gca(aspect='equal')

Graph_min, Graph_max = 10, 400
plt.xlim((Graph_min, Graph_max))
plt.ylim((Graph_min, Graph_max))

colors = ['r+', 'g+', 'm+']
for i, cluster in enumerate(clusters):
    xs, ys = zip(*cluster)
    plt.plot(xs, ys, colors[i])

plt.plot(centrosx1, centrosy1, '--ro')
plt.plot(centrosx2, centrosy2, '--go')
plt.plot(centrosx3, centrosy3, '--mo')

for x, y in centroids:
    circle = plt.Circle((x, y), r, fill=True, alpha=0.3)
    ax.add_artist(circle)

plt.title("Energy Efficiency applying K-means Clustering")
plt.xlabel("X Axis")
plt.ylabel("Y Axis")
plt.show()
plt.savefig('K-means')

# programa artigo cluster melhor rota menor potencia V14.0
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#---------------------------------------------------
"""
Trabalho final de Machine Learning
Projeto de Pesquisa Engenharia Elétrica Unesp SJBV
CLUSTERS
 3 clusters in 2 dimensions
- Implement the k-means algorithm and train the system:
   - Initialize the cluster centers in random points (colored circles)
   - Adopt as your distance criteria the R from Friis´ Law
GOAL: Plot the path of the 3 centers (like in the first figure!)
""
@author: mauricio
"""
import random,  math
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle, PathPatch
from matplotlib.text import TextPath
from matplotlib.transforms import Affine2D
# This import registers the 3D projection, but is otherwise unused.
#from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
#import mpl_toolkits.mplot3d.art3d as art3d

def Minkowski(point, center, lamb):
  v = []
  for k in range(0, len(point)):
      dif = (abs((point[k] - center[k])))**lamb
      v.append(dif)
  dist = sum(v)**(1/lamb)
  return(dist)
# generation of points (x,y) that means nodes positions of an IoT network
def generatepoints(totSensors,  limit):
    global XY
    XY = []
    for x in range(totSensors):
        valueX = random.randint(1,limit)
        valueY = random.randint(1,limit)
        xy = (valueX, valueY)
        XY.append(xy)
    print(XY)
    return(XY)

# Variables Initialization
# TRANSCEIVER Frequency 2,4 Ghz (obtained from datasheet)
FREQ=2.4*10**9
# Reception Power (dBm)
PrdBm=-80
# Transmition Power (dBm)
Pt_transceiver=0.001 #centroid
Pr=10**(PrdBm/10)/1000
# Sensors Position (x,y) Distance Calculation
# Euclidian Distance between sensors (Pitagoras)
deltax = 0.
deltay = 0.
def calculaR(x1, x2, y1, y2):
    global R
    R = 0.
    deltax = x1-x2
    deltay = y1-y2
    R =  (deltax**2 + deltay**2)**0.5
    return(R)
#Max Ray calculation from Friis´s Law
def RMax(Pt,  Pr,  LAMBDA):
    rmax = ((Pt/Pr)**0.5)*LAMBDA/(4*math.pi)
    return(rmax)
totSensors = 0
# official speed of ligtht
LAMBDA = 299792458/(FREQ)
r=RMax(Pt_transceiver,Pr,LAMBDA)

print(r)
# number of iterations of loop of the clusters
var_iteration=5000
# B PART --------------------------
#totSensors = int(input('Defina o total de pontos: '))
#limit = int(input('Defina a faixa randomica: '))
# ------------------------------------------------------ Sensores e Range --------------
# Generate 128 points X,Y randomlythat represents position of SENSORS
totSensors =128
limit = 400 #top range of points
generatepoints(totSensors, limit)
#Initialization
# CALCULAR AS POTÊNCIAS DE TRANSMISSÃO DAS ANTENAS
# LEI DE FRIIS --- POTÊNCIA TRANSMITIDA DE UMA ANTENA PARA OUTRA
#FIXAR AS CONSTANTES GT E GR
GT = 1.
GR = 1.
R = 1.
# initialization POTÊNCIA DE TRANSMISSÃO DA ANTENA
PT = 1.
# initialization POTÊNCIA DE RECEPÇÃO DA ANTENA
PR = 1.
# USAREMOS UM TRANSCEIVER ARDUINO DE FREQUÊNCIA 2.4 GHz (Datasheet)
# USANDO V = LAMBDA * F, onde V = velocidade da Luz 299.792.458 Km/s
# https://pt.wikipedia.org/wiki/Velocidade_da_luz
# 299.792.458 = LAMBDA * 2.4*10**9
# temos que LAMBDA = 299.792.458/2.4
#print('LAMBDA = ',  LAMBDA)

PT = PR/(GT*GR*((LAMBDA/4*math.pi*R)**2))

# - CALCULAR O R (EUCLIDEANA/PITÁGORAS),
#print('R = ',  R)
## CALCULAR A DISTANCIA
## CALCULAR A POTENCIA TRANSMITIDA E RECEBIDA
## USAR A MENOR POTENCIA PARA TRANSMITIR
pontosx = []
pontosy = []
#print('lenXY = ', len(XY))
#print('XY fora do def',  XY)
for i in range(0,len(XY)):
     x = float(XY[i][0])
     y = float(XY[i][1])
     pontosx.append(x)
     pontosy.append(y)
# ------Data generated must be saved to be runnable -----
# creating an new empty file to save all points/sensors
salvos = 0
name_file=str('C:\pointsxy'+str(var_iteration)+'.txt')
file = open(name_file, 'w')
file.close()
file = open(name_file, 'w') # Abre novamente o arquivo (write)

pontosR = []
# --------------quarta --A FAZER ------
# 1) calculo dist x,y ===> centroide
# 2) automatizar +clusters (cor automática, RGB)
# 3) validar (x,y) está dentro do raio r do centroide do cluster considerado
#------------------ quinta - 05/12-------------------
# CALCULAR o R entre o centroide e cada ponto (x,y)
#a) MATRIZ DISTÂNCIA: REFAZER esse laço: de M X N (128X128)
#PointsRmax = []
# distance calculation between points ---------------R --------
# duvida: este laço entre pontos é inutil ???? pend
# -------------- alterando para centroid o primeiro ponto
# centroids initialization
# parâmetro: numero de centroides do K-means => K <=
# --------------- alteracao => usar os pontos x,y do generatepoints
# k if fixed, at this moment.
# Centroids random initialization
k = 4
x1 = random.uniform(0,limit)
y1 = random.uniform(0,limit)
x2 = random.uniform(0,limit)
y2 = random.uniform(0,limit)
x3 = random.uniform(0,limit)
y3 = random.uniform(0,limit)
x4 = random.uniform(0,limit)
y4 = random.uniform(0,limit)
centroidsx = [x1,x2,x3,x4]
centroidsy = [y1,y2,y3,y4]
print(centroidsx,centroidsy)
for i in range(len(pontosx)):
    # fixar o primeiro ponto e calcular a distância R para o centroid(j)
     x = pontosx[i]
     y = pontosy[i]
     for j in range(1,4):
         x2 = centroidsx[j]
         y2 = centroidsy[j]
         if (x-x2 ==0) and (y-y2==0):
             R = 0
         else:
             calculaR(x, x2, y, y2)
         # CALCULAR A POTENCIA TRANSMITIDA ------------------------PT
         PT = PR/(GT*GR*((LAMBDA/4*math.pi*R)**2))
         pontosR.append(str(pontosx[i])+" "+str(pontosy[i])+" "+str(R)+" "+str(PT)+str('\n'))
         file.write(str(pontosx[i])+" "+str(pontosy[i])+" "+str(R)+" "+str(PT)+str('\n'))
         salvos = salvos+1
file.close()
print('records = ', salvos)
#Assign the cluster centers ! " to those points
m1=(x1,y1)
m2=(x2,y2)
m3=(x3,y3)
m4=(x4,y4)
# saving randomic centroids
name_file2=str('C:\centroids_start'+str(var_iteration)+'.txt')

file2 = open(name_file2, 'w')
file2.close()
file2 = open(name_file2, 'w') # Abre novamente o arquivo (write)
file2.write(str(m1)+" "+str(m2)+" "+str(m3)+str('\n'))
file2.close()
centrosx1 = []
centrosx2 = []
centrosx3 = []
centrosx4 = []
centrosy1 = []
centrosy2 = []
centrosy3 = []
centrosy4 = []
centrosx1.append(x1)
centrosx2.append(x2)
centrosx3.append(x3)
centrosx4.append(x4)
centrosy1.append(y1)
centrosy2.append(y2)
centrosy3.append(y3)
centrosy4.append(y4)
#Learning
#§ Repeat until the cluster centers stop moving:
#while ..........
#    For each datapoint # $ :
#▪ Compute the distance from Xi to each cluster center m1,m2,m3
#Assign the datapoint to the nearest cluster center mj with distance % $ = min % # $ , ! ")
d1 = []
d2 = []
d3 = []
d4 = []
cluster = 0
centerc1 = []
centerc2 = []
centerc3 = []
centerc4 = []
centerc1x = []
centerc2x = []
centerc3x = []
centerc4x = []
centerc1y = []
centerc2y = []
centerc3y = []
centerc4y = []
############### LEARNING #######################
######### distance
iteration = 0
centers1x = []
centers1y = []
centers2x = []
centers2y = []
centers3x = []
centers3y = []
centers4x = []
centers4y = []
d1x = []
d1y = []
d2x = []
d2y = []
d3x = []
d3y = []
d4x = []
d4y = []
plt.clf
#alterar para erro = 0
# rever aqui: condicao de parada == ERRO = 0
#pend
# --------------------------------alterar aqui ----------------- while ---------------]
# PARAR QUANDO OS CENTROIDES NAO ANDAREM MAIS...
while iteration < var_iteration:
    iteration = iteration + 1
    #print('iteration ', iteration)
    #print('gerando OS 3 CLUSTERs',len(pontosx))
    for i in range(0,len(pontosx)):
        pointcluster = ''
        dist1 = 0.
        dist2 = 0.
        dist3 = 0.
        dist4 = 0.
        x = pontosx[i]
        y = pontosy[i]
# nao alteracao do calculo distancia  do ponto para o ponto médio atual
        dist1 = (Minkowski((x,y), m1, 1))
        dist2 = (Minkowski((x,y), m2, 1))
        dist3 = (Minkowski((x,y), m3, 1))
        dist4 = (Minkowski((x,y), m4, 1))
        #d = dist1, dist2, dist3
        #print(d)
        # put x,y in his nearest Cluster: classification
        if (dist1 < dist2) and (dist1 < dist3) and (dist1 < dist4):
            cluster = 1
            pointcluster=str(x)+' '+str(y)+' '+str(dist1)+' '+str(cluster)
            d1.append(pointcluster)
            d1x.append(x)
            d1y.append(y)
        if (dist2 < dist3) and (dist2 < dist1) and (dist2 < dist4):
            cluster = 2
            pointcluster=str(x)+' '+str(y)+' '+str(dist2)+' '+str(cluster)
            d2.append(pointcluster)
            d2x.append(x)
            d2y.append(y)
        if (dist3 < dist1) and (dist3 < dist2) and (dist3 < dist4):
            cluster = 3
            pointcluster=str(x)+' '+str(y)+' '+str(dist3)+' '+str(cluster) #estava dist2
            d3.append(pointcluster)
            d3x.append(x)
            d3y.append(y)
        if (dist4 < dist1) and (dist4 < dist2) and (dist4 < dist3):
            cluster = 4
            pointcluster=str(x)+' '+str(y)+' '+str(dist4)+' '+str(cluster)
            d4.append(pointcluster)
            d4x.append(x)
            d4y.append(y)
    sumx1 = 0
    sumx2 = 0
    sumx3 = 0
    sumx4 = 0
    sumy1 = 0
    sumy2 = 0
    sumy3 = 0
    sumy4 = 0
    for j in range(0,len(d1x)):
        x = d1x[j]
        y = d1y[j]
        sumx1 = sumx1 + x
        sumy1 = sumy1 + y
    for k in range(0,len(d2x)):
        x = d2x[k]
        y = d2y[k]
        sumx2 = sumx2 + x
        sumy2 = sumy2 + y
    for m in range(0, len(d3x)):
        x = d3x[m]
        y = d3y[m]
        sumx3 = sumx3 + x
        sumy3 = sumy3 + y
    for n in range(0, len(d4x)):
        x = d4x[n]
        y = d4y[n]
        sumx4 = sumx4 + x
        sumy4 = sumy4 + y
    n1 = len(d1x)
    n2 = len(d2x)
    n3 = len(d3x)
    n4 = len(d4x)
    meanc1x1 = 0.
    meanc2x2 = 0.
    meanc3x3 = 0.
    meanc4x4 = 0.
    meanc1y1 = 0.
    meanc2y2 = 0.
    meanc3y3 = 0.
    meanc4y4 = 0.
    try:
        meanc1x1 = sumx1/n1
    except:
        print("n1 = 0, An exception occurred")
    try:
        meanc2x2 = sumx2/n2
    except:
        print("n2 = 0, An exception occurred")
    try:
        meanc3x3 = sumx3/n3
    except:
          print("n3 = 0, An exception occurred")
    try:
        meanc4x4 = sumx4/n4
    except:
        print("n4 = 0, An exception occurred")
    try:
        meanc1y1 = sumy1/n1
    except:
         print("n1 = 0, An exception occurred")
    try:
        meanc2y2 = sumy2/n2
    except:
        print("n2 = 0, An exception occurred")
    try:
        meanc3y3 = sumy3/n3
    except:
        print("n3 = 0, An exception occurred")
    try:
        meanc4y4 = sumy4/n4
    except:
        print("n4= 0, An exception occurred")
    meanc1 = 0.
    meanc2 = 0.
    meanc3 = 0.
    meanc4 = 0.
#For each cluster center:
#▪ Pre-Move the position of the center to the mean of the points in the data cluster
    meanc1 = (meanc1x1,meanc1y1)
    centers1x.append(meanc1x1)
    centers1y.append(meanc1y1)
    meanc2 = (meanc2x2,meanc2y2)
    centers2x.append(meanc2x2)
    centers2y.append(meanc2y2)
    meanc3 = (meanc3x3,meanc3y3)
    centers3x.append(meanc3x3)
    centers3y.append(meanc3y3)
    meanc4 = (meanc4x4,meanc4y4)
    centers4x.append(meanc4x4)
    centers4y.append(meanc4y4)
    x1 = meanc1x1
    y1 = meanc1y1
    x2 = meanc2x2
    y2 = meanc2y2
    x3 = meanc3x3
    y3 = meanc3y3
    x4 = meanc4x4
    y4 = meanc4y4
############ move the center to the mean of the points in the data cluster
    m1 = meanc1
    m2 = meanc2
    m3 = meanc3
    m4 = meanc4
    totin1 = 0
    totin2 = 0
    totin3 = 0
    totin4 = 0
    totout1 = 0
    totout2 = 0
    totout3 = 0
    totout4 = 0
# Check if (x,y) of a New centroid(i) is in range of his RMax Ray.
# if no, create another cluster and repeat the process...
# centroid #1
    for j in range(0,len(d1x)):
        x = d1x[j]
        y = d1y[j]
        calculaR(x,x1,y,y1)
        if R > r:
            # itsn´t in RMax
            # create another cluster
            totout1 = totout1 + 1
            #print('point ', x,y, 'is outside of RMax1')
        else:
            totin1 = totin1 + 1
            #print('point ', x,y, 'is inside of RMax1')
# centroid #2
    for j in range(0,len(d2x)):
        x = d2x[j]
        y = d2y[j]
        calculaR(x,x2,y,y2)
        if R > r:
            # itsn´t in Rmax
            # create another cluster
            totout2 = totout2 + 1
            #print('point ', x,y, 'is outside of RMax2')
        else:
            totin2 = totin2 + 1
            #print('point ', x,y, 'is inside of RMax2')
# centroid #3
    for j in range(0,len(d3x)):
        x = d3x[j]
        y = d3y[j]
        calculaR(x,x3,y,y3)
        if R > r:
            # itsn´t in Rmax
            # create another cluster
            totout3 = totout3 + 1
            #print('point ', x,y, 'is outside of RMax3')
        else:
            totin3 = totin3 + 1
            #print('point ', x,y, 'is inside of RMax3')
# centroid #4
    for j in range(0,len(d4x)):
        x = d4x[j]
        y = d4y[j]
        calculaR(x,x4,y,y4)
        if R > r:
            # itsn´t in Rmax
            # create another cluster
            totout3 = totout4 + 1
            #print('point ', x,y, 'is outside of RMax3')
        else:
            totin4 = totin4 + 1
            #print('point ', x,y, 'is inside of RMax3')

#------------------- create anoter cluster-------- fazer sexta..

# end of loop -------------------------------------------- end of loop ----------
print(m1, 'totin1 = ', totin1, ' totout1 = ', totout1)
print(m2, 'totin2 = ', totin2, ' totout2 = ', totout2)
print(m3, 'totin3 = ', totin3, ' totout3 = ', totout3)
print(m4, 'totin4 = ', totin4, ' totout4 = ', totout4)

# Calcular o RMax com os centroides (02dez2019)
# duvida: para o centroixe x1,y1 , para calcular o R, pego o x,y mais distante? pend abaixo?
calculaR(x1, x2, y1, y2)
#print('x,x2,y,y2,R = ', x, x2, y, y2, R)
# CALCULAR A POTENCIA TRANSMITIDA
PT = PR/(GT*GR*((LAMBDA/4*math.pi*R)**2))
# calculate MaxRadius for each centroid.............. pend
MaxRadius = RMax(PT, PR, LAMBDA)
print("PT = ", PT, "MaxRadius = ', MaxRadius)
# C PART
#  Plot the path of the 3 centers (like in the first figure!)
print('Centroids')
print(' m1 = ',m1,'\n', 'm2 = ', m2,'\n', 'm3 = ', m3, '\n', 'm4 = ',m4)
plt.figure(1)
plt.clf()
plt.plot(centers1x, centers1y,'--ro'  )
plt.plot(centers1x[iteration-1],centers1y[iteration-1],'ko',markersize =10)
plt.plot(centers2x, centers2y,'--ro')
plt.plot(centers2x[iteration-1],centers2y[iteration-1],'ko',markersize =10)
plt.plot(centers3x, centers3y,'--ro')
plt.plot(centers3x[iteration-1],centers3y[iteration-1],'ko',markersize =10)
plt.plot(centers4x, centers4y,'--ro')
plt.plot(centers4x[iteration-1],centers3y[iteration-1],'ko',markersize =10)
plt.plot(d1x,d1y,'r+')
plt.plot(d2x,d2y,'g+')
plt.plot(d3x,d3y,'m+')
plt.plot(d4x,d4y,'y+')

Graph_min=-50
Graph_max=400
Graph_div=50
# D PART
# Plot the circle with ray r, from Potency Pt
plt.figure(figsize=(10,10))
ax = plt.gca(aspect='equal')

Graph_min=-50
Graph_max=400
Graph_div=50

plt.xlim((Graph_min, Graph_max))
plt.ylim((Graph_min, Graph_max))

plt.plot(centers1x, centers1y,'--ro'  )
plt.plot(centers1x[iteration-1],centers1y[iteration-1],'ko',markersize =10)
plt.plot(centers2x, centers2y,'--ro')
plt.plot(centers2x[iteration-1],centers2y[iteration-1],'ko',markersize =10)
plt.plot(centers3x, centers3y,'--ro')
plt.plot(centers3x[iteration-1],centers3y[iteration-1],'ko',markersize =10)
plt.plot(centers4x, centers4y,'--ro')
plt.plot(centers4x[iteration-1],centers3y[iteration-1],'ko',markersize =10)
plt.plot(d1x,d1y,'r+')
plt.plot(d2x,d2y,'g+')
plt.plot(d3x,d3y,'m+')
plt.plot(d4x,d4y,'y+')

circle=plt.Circle((x1,y1),r,fill=True,alpha=0.3)
ax.add_artist(circle)

circle=plt.Circle((x2,y2),r,fill=True,alpha=0.3)
ax.add_artist(circle)

circle=plt.Circle((x3,y3),r,fill=True,alpha=0.3)
ax.add_artist(circle)

circle=plt.Circle((x4,y4),r,fill=True,alpha=0.3)
ax.add_artist(circle)

print(r)
plt.title("K-means IoT Sensors Clustering MaxRay MinPower")
plt.xlabel("X Axis")
plt.ylabel("Y Axis")
plt.show()
plt.savefig('K-means')